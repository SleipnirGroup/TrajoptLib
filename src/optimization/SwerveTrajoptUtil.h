// Copyright (c) TrajoptLib contributors

#pragma once

#include <utility>
#include <vector>

#include "optimization/HolonomicTrajoptUtil.h"
#include "optimization/OptiSys.h"
#include "optimization/TrajoptUtil.h"
#include "trajopt/drivetrain/SwerveDrivetrain.h"
#include "trajopt/path/Path.h"
#include "trajopt/solution/SwerveSolution.h"

namespace trajopt {

template <typename Expr>
  requires ExprSys<Expr>
std::pair<Expr, Expr> SolveNetForce(const std::vector<Expr>& Fx,
                                    const std::vector<Expr>& Fy);

template <typename Expr>
  requires ExprSys<Expr>
Expr SolveNetTorque(const Expr& thetacos, const Expr& thetasin, const std::vector<Expr>& Fx,
                    const std::vector<Expr>& Fy,
                    const std::vector<SwerveModule>& swerveModules);

template <typename Expr, typename Opti>
  requires OptiSys<Expr, Opti>
void ApplyKinematicsConstraints(
    Opti& opti, const std::vector<Expr>& x, const std::vector<Expr>& y,
    const std::vector<Expr>& thetacos, const std::vector<Expr>& thetasin,
     const std::vector<Expr>& vx,
    const std::vector<Expr>& vy, const std::vector<Expr>& omega,
    const std::vector<Expr>& ax, const std::vector<Expr>& ay,
    const std::vector<Expr>& alpha, const std::vector<Expr>& dt,
    const std::vector<size_t> N);

/**
 * Applies the drivetrain-specific constraints to the optimizer. These
 * constraints prevent motors from spinning too fast or with too much power.
 * For swerve, this applies constraints that connect the speed and direction
 * of each swerve module wheel to the overall kinematics and dynamics of the
 * system. There are two parts: the velocity of each wheel is connected to the
 * velocity of the robot, and the force generated by each wheel is connected
 * to the acceleration of the robot. For both of these, limits are placed on
 * the speed and torque of each wheel. This allows the optimizer to generate
 * an efficient, smooth path that the robot can follow.
 *
 * @param opti the current optimizer upon which constraints will be applied
 * @param theta (controlIntervalTotal + 1) x 1 column vector of the robot's
 * heading for each sample point
 * @param vx (controlIntervalTotal + 1) x 1 column vector of the x-coordinate
 * of the robot's velocity for each sample point
 * @param vy (controlIntervalTotal + 1) x 1 column vector of the y-coordinate
 * of the robot's velocity for each sample point
 * @param omega (controlIntervalTotal + 1) x 1 column vector of the robot's
 * angular velocity for each sample point
 * @param ax controlIntervalTotal x 1 column vector of the x-coordinate of the
 * robot's acceleration for each sample point
 * @param ay controlIntervalTotal x 1 column vector of the y-coordinate of the
 * robot's acceleration for each sample point
 * @param alpha controlIntervalTotal x 1 column vector of the robot's angular
 * velocity for each sample point
 * @param swerveDrivetrain the swerve drivetrain
 */
template <typename Expr, typename Opti>
  requires OptiSys<Expr, Opti>
void ApplyDynamicsConstraints(Opti& opti, const Expr& ax, const Expr& ay,
                              const Expr& alpha, const Expr& Fx_net,
                              const Expr& Fy_net, const Expr& tau_net,
                              double mass, double moi);

template <typename Expr, typename Opti>
  requires OptiSys<Expr, Opti>
void ApplyPowerConstraints(Opti& opti, const Expr& thetacos, const Expr& thetasin, const Expr& vx,
                           const Expr& vy, const Expr& omega,
                           const std::vector<Expr>& Fx,
                           const std::vector<Expr>& Fy,
                           const SwerveDrivetrain& swerveDrivetrain);

template <typename Expr, typename Opti>
  requires OptiSys<Expr, Opti>
SwerveSolution ConstructSwerveSolution(
    const Opti& opti, const std::vector<Expr>& x, const std::vector<Expr>& y,
    const std::vector<Expr>& thetacos, const std::vector<Expr>& thetasin, const std::vector<Expr>& vx,
    const std::vector<Expr>& vy, const std::vector<Expr>& omega,
    const std::vector<Expr>& ax, const std::vector<Expr>& ay,
    const std::vector<Expr>& alpha, const std::vector<std::vector<Expr>>& Fx,
    const std::vector<std::vector<Expr>>& Fy, const std::vector<Expr>& dt,
    const std::vector<size_t>& N);
}  // namespace trajopt

#include "optimization/SwerveTrajoptUtil.inc"
