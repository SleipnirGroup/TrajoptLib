// Copyright (c) TrajoptLib contributors

#pragma once

#include <numeric>
#include <utility>
#include <vector>

#include <sleipnir/autodiff/Variable.hpp>
#include <sleipnir/optimization/OptimizationProblem.hpp>

#include "optimization/TrajoptUtil.hpp"
#include "trajopt/drivetrain/SwerveDrivetrain.hpp"
#include "trajopt/geometry/Translation2.hpp"
#include "trajopt/solution/SwerveSolution.hpp"

namespace trajopt {

inline std::pair<sleipnir::Variable, sleipnir::Variable> SolveNetForce(
    const std::vector<sleipnir::Variable>& Fx,
    const std::vector<sleipnir::Variable>& Fy) {
  return {std::accumulate(Fx.begin(), Fx.end(), sleipnir::Variable{0.0}),
          std::accumulate(Fy.begin(), Fy.end(), sleipnir::Variable{0.0})};
}

inline sleipnir::Variable SolveNetTorque(
    const Rotation2v& theta, const std::vector<sleipnir::Variable>& Fx,
    const std::vector<sleipnir::Variable>& Fy,
    const std::vector<SwerveModule>& swerveModules) {
  sleipnir::Variable tau_net = 0;

  for (size_t moduleIndex = 0; moduleIndex < swerveModules.size();
       ++moduleIndex) {
    auto& swerveModule = swerveModules.at(moduleIndex);

    const auto& [x_m, y_m] = swerveModule.translation.RotateBy(theta);
    Translation2v r{x_m, y_m};

    Translation2v F{Fx.at(moduleIndex), Fy.at(moduleIndex)};

    tau_net += r.Cross(F);
  }

  return tau_net;
}

inline void ApplyKinematicsConstraints(
    sleipnir::OptimizationProblem& problem,
    const std::vector<sleipnir::Variable>& x,
    const std::vector<sleipnir::Variable>& y,
    const std::vector<sleipnir::Variable>& thetacos,
    const std::vector<sleipnir::Variable>& thetasin,
    const std::vector<sleipnir::Variable>& vx,
    const std::vector<sleipnir::Variable>& vy,
    const std::vector<sleipnir::Variable>& omega,
    const std::vector<sleipnir::Variable>& ax,
    const std::vector<sleipnir::Variable>& ay,
    const std::vector<sleipnir::Variable>& alpha,
    const std::vector<sleipnir::Variable>& dt, const std::vector<size_t>& N) {
  size_t wptCnt = N.size() + 1;

  for (size_t wptIndex = 1; wptIndex < wptCnt; ++wptIndex) {
    size_t N_sgmt = N.at(wptIndex - 1);
    auto dt_sgmt = dt.at(wptIndex - 1);
    for (size_t sampIndex = 0; sampIndex < N_sgmt; ++sampIndex) {
      size_t index = GetIndex(N, wptIndex, sampIndex);
      auto x_n = x.at(index);
      auto x_n_1 = x.at(index - 1);
      auto y_n = y.at(index);
      auto y_n_1 = y.at(index - 1);
      Rotation2v theta_n{thetacos.at(index), thetasin.at(index)};
      Rotation2v theta_n_1{thetacos.at(index - 1), thetasin.at(index - 1)};
      auto vx_n = vx.at(index);
      auto vx_n_1 = vx.at(index - 1);
      auto vy_n = vy.at(index);
      auto vy_n_1 = vy.at(index - 1);
      auto omega_n = omega.at(index);
      auto omega_n_1 = omega.at(index - 1);
      auto ax_n = ax.at(index);
      auto ay_n = ay.at(index);
      auto alpha_n = alpha.at(index);

      problem.SubjectTo(x_n_1 + vx_n * dt_sgmt == x_n);
      problem.SubjectTo(y_n_1 + vy_n * dt_sgmt == y_n);

      auto theta_diff = theta_n - theta_n_1;

      // Constrain angle equality on manifold: theta_diff = omega_n * dt_sgmt.
      //
      // Let a = <cos(theta_diff), sin(theta_diff)>.  NOLINT
      // Let b = <cos(omega_n * dt_sgmt), sin(omega_n * dt_sgmt)>.  NOLINT
      //
      // If the angles are equal, the angle between the unit vectors should be
      // zero.
      //
      //   a x b = ||a|| ||b|| sin(angleBetween)  NOLINT
      //         = 1 * 1 * 0
      //         = 0
      //
      // NOTE: angleBetween = Ï€ rad would be another solution
      Translation2v a{theta_diff.Cos(), theta_diff.Sin()};
      Translation2v b{sleipnir::cos(omega_n * dt_sgmt),
                      sleipnir::sin(omega_n * dt_sgmt)};
      problem.SubjectTo(a.Cross(b) == 0);
      problem.SubjectTo(
          Translation2v{theta_n_1.Cos(), theta_n_1.Sin()}.SquaredNorm() == 1);

      problem.SubjectTo(vx_n_1 + ax_n * dt_sgmt == vx_n);
      problem.SubjectTo(vy_n_1 + ay_n * dt_sgmt == vy_n);
      problem.SubjectTo(omega_n_1 + alpha_n * dt_sgmt == omega_n);
    }
    size_t lastIndex = GetIndex(N, wptIndex, N_sgmt - 1);
    problem.SubjectTo(thetacos.at(lastIndex) * thetacos.at(lastIndex) +
                          thetasin.at(lastIndex) * thetasin.at(lastIndex) ==
                      1);
  }
}

/**
 * Applies the drivetrain-specific constraints to the optimizer. These
 * constraints prevent motors from spinning too fast or with too much power.
 * For swerve, this applies constraints that connect the speed and direction
 * of each swerve module wheel to the overall kinematics and dynamics of the
 * system. There are two parts: the velocity of each wheel is connected to the
 * velocity of the robot, and the force generated by each wheel is connected
 * to the acceleration of the robot. For both of these, limits are placed on
 * the speed and torque of each wheel. This allows the optimizer to generate
 * an efficient, smooth path that the robot can follow.
 *
 * @param problem the current optimization problem to which to apply constraints
 * @param theta (controlIntervalTotal + 1) x 1 column vector of the robot's
 * heading for each sample point
 * @param vx (controlIntervalTotal + 1) x 1 column vector of the x-coordinate
 * of the robot's velocity for each sample point
 * @param vy (controlIntervalTotal + 1) x 1 column vector of the y-coordinate
 * of the robot's velocity for each sample point
 * @param omega (controlIntervalTotal + 1) x 1 column vector of the robot's
 * angular velocity for each sample point
 * @param ax controlIntervalTotal x 1 column vector of the x-coordinate of the
 * robot's acceleration for each sample point
 * @param ay controlIntervalTotal x 1 column vector of the y-coordinate of the
 * robot's acceleration for each sample point
 * @param alpha controlIntervalTotal x 1 column vector of the robot's angular
 * velocity for each sample point
 * @param swerveDrivetrain the swerve drivetrain
 */
inline void ApplyDynamicsConstraints(
    sleipnir::OptimizationProblem& problem, const sleipnir::Variable& ax,
    const sleipnir::Variable& ay, const sleipnir::Variable& alpha,
    const sleipnir::Variable& Fx_net, const sleipnir::Variable& Fy_net,
    const sleipnir::Variable& tau_net, double mass, double moi) {
  problem.SubjectTo(Fx_net == mass * ax);
  problem.SubjectTo(Fy_net == mass * ay);
  problem.SubjectTo(tau_net == moi * alpha);
}

inline void ApplyPowerConstraints(sleipnir::OptimizationProblem& problem,
                                  const Rotation2v& theta,
                                  const Translation2v& v,
                                  const sleipnir::Variable& omega,
                                  const std::vector<sleipnir::Variable>& Fx,
                                  const std::vector<sleipnir::Variable>& Fy,
                                  const SwerveDrivetrain& swerveDrivetrain) {
  const auto [vx_prime, vy_prime] = v.RotateBy(-theta);

  size_t moduleCount = swerveDrivetrain.modules.size();

  std::vector<sleipnir::Variable> vx_m;
  std::vector<sleipnir::Variable> vy_m;
  vx_m.reserve(moduleCount);
  vy_m.reserve(moduleCount);

  for (size_t moduleIndex = 0; moduleIndex < moduleCount; ++moduleIndex) {
    const auto& [x_m, y_m] =
        swerveDrivetrain.modules.at(moduleIndex).translation;
    vx_m.emplace_back(vx_prime - y_m * omega);
    vy_m.emplace_back(vy_prime + x_m * omega);
  }

  for (size_t moduleIndex = 0; moduleIndex < moduleCount; ++moduleIndex) {
    auto& _module = swerveDrivetrain.modules.at(moduleIndex);
    double maxWheelVelocity =
        _module.wheelRadius * _module.wheelMaxAngularVelocity;
    double maxForce = _module.wheelMaxTorque / _module.wheelRadius;
    auto _vx_m = vx_m.at(moduleIndex);
    auto _vy_m = vy_m.at(moduleIndex);
    auto Fx_m = Fx.at(moduleIndex);
    auto Fy_m = Fy.at(moduleIndex);
    problem.SubjectTo(_vx_m * _vx_m + _vy_m * _vy_m <=
                      maxWheelVelocity * maxWheelVelocity);

    problem.SubjectTo(Fx_m * Fx_m + Fy_m * Fy_m <= maxForce * maxForce);
  }
}

inline SwerveSolution ConstructSwerveSolution(
    std::vector<sleipnir::Variable>& x, std::vector<sleipnir::Variable>& y,
    std::vector<sleipnir::Variable>& thetacos,
    std::vector<sleipnir::Variable>& thetasin,
    std::vector<sleipnir::Variable>& vx, std::vector<sleipnir::Variable>& vy,
    std::vector<sleipnir::Variable>& omega, std::vector<sleipnir::Variable>& ax,
    std::vector<sleipnir::Variable>& ay, std::vector<sleipnir::Variable>& alpha,
    std::vector<std::vector<sleipnir::Variable>>& Fx,
    std::vector<std::vector<sleipnir::Variable>>& Fy,
    std::vector<sleipnir::Variable>& dt, const std::vector<size_t>& N) {
  std::vector<double> dtPerSamp;
  for (size_t sgmtIndex = 0; sgmtIndex < N.size(); ++sgmtIndex) {
    size_t N_sgmt = N.at(sgmtIndex);
    sleipnir::Variable dt_sgmt = dt.at(sgmtIndex);
    double dt_val = dt_sgmt.Value();
    for (size_t i = 0; i < N_sgmt; ++i) {
      dtPerSamp.push_back(dt_val);
    }
  }
  return SwerveSolution{
      {{dtPerSamp, RowSolutionValue(x), RowSolutionValue(y),
        RowSolutionValue(thetacos), RowSolutionValue(thetasin)},
       RowSolutionValue(vx),
       RowSolutionValue(vy),
       RowSolutionValue(omega),
       RowSolutionValue(ax),
       RowSolutionValue(ay),
       RowSolutionValue(alpha)},
      MatrixSolutionValue(Fx),
      MatrixSolutionValue(Fy)};
}

}  // namespace trajopt
